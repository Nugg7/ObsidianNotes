### Definizione 
---
Anche angular e' una SPA (Single Page Application).
Si usa TypeScript, e' una super-set di JavaScript e introduce cose come i tipi.
e.g.

```ts
const str: string = "kkk";
const num: number = 22;
let v: number;
v = 420;
```

Tuttavia non e' sempre necessario dichiarare il tipo, visto che se non lo dichiariamo, lo deduce direttamente TypeScript quando viene assegnato un valore. Mentre se non viene assegnato un valore bisogna dichiarare obbligatoriamente il tipo.

```ts
let v1;
```

In questo caso invece stiamo dando a `v1` il tipo `any`, che accetta tutti i tipi di variabile.

```ts
type Persona = {
	nome: stirng,
	cognome: string,
	eta: number
	indirizzo?: string
}

const persona: Persona = {
	//code...
}
```

Cosi' possiamo definire il tipo custom di un oggetto. Mentre il campo indirizzo puo' essere omesso visto che l'abbiamo definito come optional.

```ts
type Persona = {
	nome: stirng,
	cognome: string,
	eta: number
	indirizzo?: string
	func(): string;
}

const persona: Persona = {
	//code...
}
```

In questo modo definisco il tipo del return della funzione nell'oggetto.

```ts
type Numero = 1 | 2 | 3;
type Personaggio = 'Pippo' | 'Pluto' | 'Paperino';

const numero: Numero = 1;
const personaggio: Personaggio = 'Pippo';

console.log('numero', numero);
console.log('personaggio', personaggio);
```

Si possono usare anche quelle che si chiamano `Literals` su React, dove possiamo assegnare ad un custom type dei valori predefiniti, e ogni variabile che ha come tipo un `Literal`, potra' avere come valore solo i valori definiti nel tipo.

```ts
type StringNumber = string | number;
function unify(var1:StringNumber, var2:StringNumber){
	if(typeof var1 === "number" && typeof var1 === "number"){
		const sum = var1 + var2;
		return "Numeric sum: " + sum;
	}
	else{
		return "Union of strings: " + var1 + " " + var2; 
	}
}

const res1 = unify(2, 5);
const res2 = unify("Adolf", "Hitler");

// res1 = "Numeric sum: 7"
// res2 = "Union of strings: Adolf Hitler"
```

In questo modo si puo' definire un tipo che puo' avere 2 tipi

```ts
type Anagrafica = {
  nome: string;
  eta: number;
};
type Indirizzo = {
  nome: string;
  via: string;
  numCivico: number;
};
type AnagraficaIndirizzo = Anagrafica & Indirizzo;
const persona: AnagraficaIndirizzo = {
  nome: 'Mario',
  eta: 20,
  via: 'Via Verdi',
  numCivico: 10,
};
console.log('persona', persona);
```

In questo modo stiamo "fondendo" (`intersecting`) 2 custom type diversi, e se avessimo avuto 2 campi con 2 tipi diversi, avremmo avuto un unico campo nel nuovo tipo che puo' avere tutte e 2 i tipi.