### Syntax
---
Query statements scan one or more tables or expressions and return a single table containing the result of the query (similar, if not the same, as the one in basic SQL).
#### Notation rules
In the documentation of google SQL (Big Query), the code is usually described through some notations as these ones:
- [] -> Optional Clause
- {a | b | c} -> logical `OR` (choose one of them)
- ... -> the item preceding them can repeat
- "" -> syntax inside them is required

```bq
SELECT
	[WITH Differential_Privacy_clause/s]
	[{ALL | DISTINCT}]
	[AS {STRUCT | VALUE}]
	select_list

- select_list:
	- {select_all | select_expresstion} [, ...]
		- select_all:
			- [expression]*
			- [EXCEPT (column_name [, ...])]
			- [REPLACE (expression as column_name [, ...])]
		- select_expression:
			- expression [[AS] alias]
```

It's practically the same as the one in SQL, * meaning all, and every little quirk like: 

Ex.
```sql
SELECT * FROM (
	SELECT 
		"apple" AS fruit, 
		"carrot" AS vegetable
)

-- output:

/*-------+-----------*
 | fruit | vegetable |
 +-------+-----------+
 | apple | carrot    |
 *-------+-----------*/
```
#### Select Expression
Then we have the **select expression**, these expressions evaluate to a single value and produce one output column with an optional explicit `alias`.
##### Select Expression.*
An item in the select list can also take the form of `expression.*`. This produces one output column for each column or top level field of expression. It has to be either a table alias or evaluate to a single value of data type with fields like structs.

Ex.
``` sql
WITH groceries AS
  (SELECT "milk" AS dairy,
   "eggs" AS protein,
   "bread" AS grain)
SELECT g.*
FROM groceries AS g;

/*-------+---------+-------*
 | dairy | protein | grain |
 +-------+---------+-------+
 | milk  | eggs    | bread |
 *-------+---------+-------*/
-- or
WITH locations AS
  (SELECT STRUCT("Seattle" AS city, "Washington" AS state) AS location
  UNION ALL
  SELECT STRUCT("Phoenix" AS city, "Arizona" AS state) AS location)
SELECT l.location.*
FROM locations l;

/*---------+------------*
 | city    | state      |
 +---------+------------+
 | Seattle | Washington |
 | Phoenix | Arizona    |
 *---------+------------*/
 -- or
WITH locations AS
  (SELECT ARRAY<STRUCT<city STRING, state STRING>>[("Seattle", "Washington"),
    ("Phoenix", "Arizona")] AS location)
SELECT l.LOCATION[offset(0)].*
FROM locations l;

/*---------+------------*
 | city    | state      |
 +---------+------------+
 | Seattle | Washington |
 *---------+------------*/
```
##### Select * Replace
A **SELECT * REPLACE** statement specifies one or more `expression as identifier` clauses. Each identifier used must match a column name from the **SELECT \*** statement. The output column list that matches the identifier in a **REPLACE**  clause will replace the instances inside of it.

The replace cannot change the names or the order of the column but it can change the values in them and the value type.

Ex.
```sql
WITH orders AS
  (SELECT 5 as order_id,
  "sprocket" as item_name,
  200 as quantity)
SELECT * REPLACE ("widget" AS item_name)
FROM orders;

/*----------+-----------+----------*
 | order_id | item_name | quantity |
 +----------+-----------+----------+
 | 5        | widget    | 200      |
 *----------+-----------+----------*/

WITH orders AS
  (SELECT 5 as order_id,
  "sprocket" as item_name,
  200 as quantity)
SELECT * REPLACE (quantity/2 AS quantity)
FROM orders;

/*----------+-----------+----------*
 | order_id | item_name | quantity |
 +----------+-----------+----------+
 | 5        | sprocket  | 100      |
 *----------+-----------+----------*/
```
##### Select Distinct
A **SELECT DISTINCT** statement discards duplicate rows but cannot return columns of the following type:

In the following example, `SELECT DISTINCT` is used to produce distinct arrays:
```sql
WITH PlayerStats AS (
  SELECT ['Coolidge', 'Adams'] as Name, 3 as PointsScored UNION ALL
  SELECT ['Adams', 'Buchanan'], 0 UNION ALL
  SELECT ['Coolidge', 'Adams'], 1 UNION ALL
  SELECT ['Kiran', 'Noam'], 1)
SELECT DISTINCT Name

/*------------------+
 | Name             |
 +------------------+
 | [Coolidge,Adams] |
 | [Adams,Buchanan] |
 | [Kiran,Noam]     |
 +------------------*/
```

In the following example, it is used to create distinct structs:
```sql
WITH
  PlayerStats AS (
    SELECT
      STRUCT<last_name STRING, first_name STRING, age INT64>(
        'Adams', 'Noam', 20) AS Player,
      3 AS PointsScored UNION ALL
    SELECT ('Buchanan', 'Jie', 19), 0 UNION ALL
    SELECT ('Adams', 'Noam', 20), 4 UNION ALL
    SELECT ('Buchanan', 'Jie', 19), 13
  )
SELECT DISTINCT Player
FROM PlayerStats;

/*--------------------------+
 | player                   |
 +--------------------------+
 | {                        |
 |   last_name: "Adams",    |
 |   first_name: "Noam",    |
 |   age: 20                |
 |  }                       |
 +--------------------------+
 | {                        |
 |   last_name: "Buchanan", |
 |   first_name: "Jie",     |
 |   age: 19                |
 |  }                       |
 +---------------------------*/
```
##### Select All
The **SELECT ALL** statement returns all rows, including duplicating ones and it is the default behavior of the **SELECT**.
##### Select As Struct
```sql
SELECT AS STRUCT expr [[AS] struct_field_name1] [,...]
```

This produces a [value table](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#value_tables) with a STRUCT row type, where the STRUCT field names and types match the column names and types produced in the `SELECT` list.

Ex.
```sql
SELECT ARRAY(SELECT AS STRUCT 1 a, 2 b)
```

In this example we can see that it can be used in a **scalar** or **array** subquery in order to produce a single struct containing all the grouped values together. (**scalar** and **array** subqueries cannot return multiple columns but can return multiple data grouped a single struct as a single column)

Ex.
Array subquery
```sql
SELECT
  ARRAY(SELECT username FROM NPCs WHERE team = 'red') AS red;

/*-----------------*
 | red             |
 +-----------------+
 | [niles,jujul]   |
 *-----------------*/
```

Scalar subquery
```sql
SELECT
  username,
  (SELECT mascot FROM Mascots WHERE Players.team = Mascots.team) AS player_mascot
FROM
  Players;

/*---------------------------*
 | username  | player_mascot |
 +---------------------------+
 | gorbie    | cardinal      |
 | junelyn   | finch         |
 | corba     | parrot        |
 *---------------------------*/
```
##### Select As Value
**SELECT As VALUE** produces a value table from any **select list that produces exactly one column**. Instead of producing an output table with only one column, the output will be a value table where the row type is the value type that was produced in one select column. **Any aliases the column had will be discarded in the value table.**
##### Value tables
In addition to normal tables in SQL, BQ also has value tables, where every row is a single value of type **STRUCT** and there are no column names.

Ex.
```sql
SELECT * FROM (SELECT AS VALUE STRUCT(123 AS a, FALSE AS b))

/*-----+-------*
 | a   | b     |
 +-----+-------+
 | 123 | FALSE |
 *-----+-------*/
```
#### From Clause
```
FROM from_clause[, ...]

from_clause:
	- from_item
	- [{pivot_operator | unipivot_operator}]
	- [tablesample_operator]
		- from_item:
			{
				table_name [as alias] [FOR SYSTEM_TIME AS OF timespamp_expression] |
				{join_operation | (join_operation)} |
				(query_expression) [as alias] |
				field_path |
				unnest_operator |
				cte_name [as alias]
			}
```

The **FROM** clause indicates the table or tables from which to retrieve data, and specifies how to join the data from the tables if 2 or more to produce a single stream of rows.
##### `For System_Time As Of`
**FOR SYSTEM_TIME AS OF** references the historical versions of the table definition and rows that were current at `timestamp_expresssion`.

Limitations: 
- The source table in the **FROM** clause containing **FOR SYSTEM_TIME AS OF** must not be any of the following:
	- Subqueries.
	- Correlated references (references to columns of a table that appear at a higher level of the query statement, such as in the `SELECT` list).
	- User-defined functions (UDFs).
- The value of `timestamp_expresssion` cannot fall in the following ranges:
	- After the current timestamp (in the future).
	- More than 7 days before the current timestamp.
- A single query statement cannot reference a single table at more than one point in time, including the current time.
The default time zone for `timestamp_expresssion` in **FOR SYSTEM_TIME AS OF** is `America/Los_Angeles`, even though the default time zones for timestamp literals is `UTC`. 

EX.
```sql
SELECT *
FROM t
  FOR SYSTEM_TIME AS OF TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 HOUR);
```

```sql
SELECT *
FROM t
  FOR SYSTEM_TIME AS OF '2017-01-01 10:00:00-07:00';
```

```sql
SELECT *
FROM t1
WHERE t1.a IN (SELECT t2.a
               FROM t2 FOR SYSTEM_TIME AS OF t1.timestamp_column);
```

The following operations show accessing a historical version of the table before table is replaced.

```sql
DECLARE before_replace_timestamp TIMESTAMP;

-- Create table books.
CREATE TABLE books AS
SELECT 'Hamlet' title, 'William Shakespeare' author;

-- Get current timestamp before table replacement.
SET before_replace_timestamp = CURRENT_TIMESTAMP();

-- Replace table with different schema(title and release_date).
CREATE OR REPLACE TABLE books AS
SELECT 'Hamlet' title, DATE '1603-01-01' release_date;

-- This query returns Hamlet, William Shakespeare as result.
SELECT * FROM books FOR SYSTEM_TIME AS OF before_replace_timestamp;
```

The following operations show accessing a historical version of the table before a DML job.

```sql
DECLARE JOB_START_TIMESTAMP TIMESTAMP;

-- Create table books.
CREATE OR REPLACE TABLE books AS
SELECT 'Hamlet' title, 'William Shakespeare' author;

-- Insert two rows into the books.
INSERT books (title, author)
VALUES('The Great Gatsby', 'F. Scott Fizgerald'),
      ('War and Peace', 'Leo Tolstoy');

SELECT * FROM books;

SET JOB_START_TIMESTAMP = (
  SELECT start_time
  FROM `region-us`.INFORMATION_SCHEMA.JOBS_BY_USER
  WHERE job_type="QUERY"
    AND statement_type="INSERT"
  ORDER BY start_time DESC
  LIMIT 1
 );

-- This query only returns Hamlet, William Shakespeare as result.
SELECT * FROM books FOR SYSTEM_TIME AS OF JOB_START_TIMESTAMP;
```

The following query returns an error because the DML operates on the current version of the table, and a historical version of the table from one day ago.

```sql
INSERT INTO t1
SELECT * FROM t1
  FOR SYSTEM_TIME AS OF TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 DAY);
```
##### Pivot operator
```
From from_item[, ...] pivot_operator
	
- pivot_operator:
	PIVOT(
		aggregate_function_call [as alias][, ...]
		For input_column
		In (pivot_column [as alias][, ...])
		) [as alias]
```

The **PIVOT** Operator rotates rows into columns, using an aggregation. Pivot is part of the **FROM** clause.
- **PIVOT** can be used to modify any table expression
- Combining **PIVOT** with **FOR SYSTEM_TIME AS OF** is not allowed, although users may use **PIVOT** against a subquery input which itself uses **FOR SYSTEM_TIME AS OF**.
- A **WITH OFFSET** clause immediately preceding the **PIVOT** operator is not allowed.

Conceptual example:
```
-- Before PIVOT is used to rotate sales and quarter into Q1, Q2, Q3, Q4 columns:
/*---------+-------+---------+------*
 | product | sales | quarter | year |
 +---------+-------+---------+------|
 | Kale    | 51    | Q1      | 2020 |
 | Kale    | 23    | Q2      | 2020 |
 | Kale    | 45    | Q3      | 2020 |
 | Kale    | 3     | Q4      | 2020 |
 | Kale    | 70    | Q1      | 2021 |
 | Kale    | 85    | Q2      | 2021 |
 | Apple   | 77    | Q1      | 2020 |
 | Apple   | 0     | Q2      | 2020 |
 | Apple   | 1     | Q1      | 2021 |
 *---------+-------+---------+------*/

-- After PIVOT is used to rotate sales and quarter into Q1, Q2, Q3, Q4 columns:
/*---------+------+----+------+------+------*
 | product | year | Q1 | Q2   | Q3   | Q4   |
 +---------+------+----+------+------+------+
 | Apple   | 2020 | 77 | 0    | NULL | NULL |
 | Apple   | 2021 | 1  | NULL | NULL | NULL |
 | Kale    | 2020 | 51 | 23   | 45   | 3    |
 | Kale    | 2021 | 70 | 85   | NULL | NULL |
 *---------+------+----+------+------+------*/
```
##### Unpivot operator
```
FROM from_item[, ...] unpivot_operator

unpivot_operator:
  UNPIVOT [ { INCLUDE NULLS | EXCLUDE NULLS } ] (
    { single_column_unpivot | multi_column_unpivot }
  ) [unpivot_alias]

single_column_unpivot:
  values_column
  FOR name_column
  IN (columns_to_unpivot)

multi_column_unpivot:
  values_column_set
  FOR name_column
  IN (column_sets_to_unpivot)

values_column_set:
  (values_column[, ...])

columns_to_unpivot:
  unpivot_column [row_value_alias][, ...]

column_sets_to_unpivot:
  (unpivot_column [row_value_alias][, ...])

unpivot_alias and row_value_alias:
  [AS] alias
```

The **UNPIVOT** operator rotates the columns into rows ad is part of the **FROM** clause.
- **UNPIVOT** can be used to modify any table expression.
- Combining **UNPIVOT** with **FOR SYSTEM_TIME AS OF** is not allowed, although users may use **UNPIVOT** against a subquery input which itself uses **FOR SYSTEM_TIME AS OF**.
- A **WITH OFFSET** clause immediately preceding the **UNPIVOT** operator is not allowed.
- **PIVOT** aggregations cannot be reversed with **UNPIVOT**.

Conceptual example:
```
-- Before UNPIVOT is used to rotate Q1, Q2, Q3, Q4 into sales and quarter columns:
/*---------+----+----+----+----*
 | product | Q1 | Q2 | Q3 | Q4 |
 +---------+----+----+----+----+
 | Kale    | 51 | 23 | 45 | 3  |
 | Apple   | 77 | 0  | 25 | 2  |
 *---------+----+----+----+----*/

-- After UNPIVOT is used to rotate Q1, Q2, Q3, Q4 into sales and quarter columns:
/*---------+-------+---------*
 | product | sales | quarter |
 +---------+-------+---------+
 | Kale    | 51    | Q1      |
 | Kale    | 23    | Q2      |
 | Kale    | 45    | Q3      |
 | Kale    | 3     | Q4      |
 | Apple   | 77    | Q1      |
 | Apple   | 0     | Q2      |
 | Apple   | 25    | Q3      |
 | Apple   | 2     | Q4      |
 *---------+-------+---------*/
```

*// the Definition of the entire thing with the practical examples will come later*.
##### Table sample operator
```
TABLESAMPLE SYSTEM ( percent PERCENT )
```

You can use the **TABLESAMPLE** operator to select a random sample of a dataset. (Practically a random picker from a large batch of files)

Sampling returns a variety of records while avoiding the costs of scanning and processing the entire table. (the results of queries that contain **TABLESAMPLE** are not cached since it returns something different every time)

*// more information in the next chapters*

Ex.
This query selects approximately 10% of the table's data randomly. 
```sql
SELECT * FROM dataset.my_table TABLESAMPLE SYSTEM (10 PERCENT)
```
##### Join operator
```
oin_operation:
  { cross_join_operation | condition_join_operation }

cross_join_operation:
  from_item cross_join_operator from_item
  
condition_join_operation:
  from_item condition_join_operator from_item join_condition

cross_join_operator:
  { CROSS JOIN | , }

condition_join_operator:
  {
    [INNER] JOIN
    | FULL [OUTER] JOIN
    | LEFT [OUTER] JOIN
    | RIGHT [OUTER] JOIN
  }

join_condition:
  { on_clause | using_clause }

on_clause:
  ON bool_expression
using_clause:
  USING ( column_list )
```

The **JOIN** Operation merges two `from_item`s so that the **SELECT** clause can query them as one source. The join operator and join condition specify how to combine and discard rows from the `from_item`s to form a single source.
###### \[Inner\] Join
An **INNER JOIN**, or simply **JOIN**, effectively calculates the cartesian product of the 2 `from_item`s discarding the rows that don't meet the join conditions. (gets the elements from the 2 tables and merges only the ones that have an equivalent on the other table)

```sql
FROM A INNER JOIN B ON A.w = B.y

/*
Table A       Table B       Result
+-------+     +-------+     +---------------+
| w | x |  *  | y | z |  =  | w | x | y | z |
+-------+     +-------+     +---------------+
| 1 | a |     | 2 | k |     | 2 | b | 2 | k |
| 2 | b |     | 3 | m |     | 3 | c | 3 | m |
| 3 | c |     | 3 | n |     | 3 | c | 3 | n |
| 3 | d |     | 4 | p |     | 3 | d | 3 | m |
+-------+     +-------+     | 3 | d | 3 | n |
                            +---------------+
*/
```

```sql
FROM A INNER JOIN B USING (x)

/*
Table A       Table B       Result
+-------+     +-------+     +-----------+
| x | y |  *  | x | z |  =  | x | y | z |
+-------+     +-------+     +-----------+
| 1 | a |     | 2 | k |     | 2 | b | k |
| 2 | b |     | 3 | m |     | 3 | c | m |
| 3 | c |     | 3 | n |     | 3 | c | n |
| 3 | d |     | 4 | p |     | 3 | d | m |
+-------+     +-------+     | 3 | d | n |
                            +-----------+
*/
```

###### Cross Join
The **CROSS JOIN** returns the cartesian product of the 2 `from_item`s. in other words, combines each row from the first table to each row of the second. (practically just mushes them together and duplicates the hell out of the rows).

```sql
FROM A CROSS JOIN B

/*
Table A       Table B       Result
+-------+     +-------+     +---------------+
| w | x |  *  | y | z |  =  | w | x | y | z |
+-------+     +-------+     +---------------+
| 1 | a |     | 2 | c |     | 1 | a | 2 | c |
| 2 | b |     | 3 | d |     | 1 | a | 3 | d |
+-------+     +-------+     | 2 | b | 2 | c |
                            | 2 | b | 3 | d |
                            +---------------+
*/
```

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster CROSS JOIN TeamMascot;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Adams      | Knights      |
 | Adams      | Lakers       |
 | Adams      | Mustangs     |
 | Buchanan   | Jaguars      |
 | Buchanan   | Knights      |
 | Buchanan   | Lakers       |
 | Buchanan   | Mustangs     |
 | ...                       |
 *---------------------------*/
```

**CROSS JOIN** can also be written implicitly with a comma. (comma cross join) like:

```sql
FROM A, B

/*
Table A       Table B       Result
+-------+     +-------+     +---------------+
| w | x |  *  | y | z |  =  | w | x | y | z |
+-------+     +-------+     +---------------+
| 1 | a |     | 2 | c |     | 1 | a | 2 | c |
| 2 | b |     | 3 | d |     | 1 | a | 3 | d |
+-------+     +-------+     | 2 | b | 2 | c |
                            | 2 | b | 3 | d |
                            +---------------+
*/
```

You cannot write comma cross joins inside parentheses.

```sql
FROM (A, B)  -- INVALID
```

This query performs a **COMMA CROSS JOIN** on the `Roster` and `TeamMascot` tables.

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster, TeamMascot;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Adams      | Knights      |
 | Adams      | Lakers       |
 | Adams      | Mustangs     |
 | Buchanan   | Jaguars      |
 | Buchanan   | Knights      |
 | Buchanan   | Lakers       |
 | Buchanan   | Mustangs     |
 | ...                       |
 *---------------------------*/
```
###### Full \[Outer\] Join
A **FULL OUTER JOIN** (or simply **FULL JOIN**) returns all fields for all matching rows in both `from_item`s that meet the join condition, if a row does not have a matching row in the other table then it merges it with a new row containing only `NULL`s.

```sql
FROM A FULL OUTER JOIN B ON A.w = B.y

/*
Table A       Table B       Result
+-------+     +-------+     +---------------------------+
| w | x |  *  | y | z |  =  | w    | x    | y    | z    |
+-------+     +-------+     +---------------------------+
| 1 | a |     | 2 | k |     | 1    | a    | NULL | NULL |
| 2 | b |     | 3 | m |     | 2    | b    | 2    | k    |
| 3 | c |     | 3 | n |     | 3    | c    | 3    | m    |
| 3 | d |     | 4 | p |     | 3    | c    | 3    | n    |
+-------+     +-------+     | 3    | d    | 3    | m    |
                            | 3    | d    | 3    | n    |
                            | NULL | NULL | 4    | p    |
                            +---------------------------+
*/
```

```sql
FROM A FULL OUTER JOIN B USING (x)

/*
Table A       Table B       Result
+-------+     +-------+     +--------------------+
| x | y |  *  | x | z |  =  | x    | y    | z    |
+-------+     +-------+     +--------------------+
| 1 | a |     | 2 | k |     | 1    | a    | NULL |
| 2 | b |     | 3 | m |     | 2    | b    | k    |
| 3 | c |     | 3 | n |     | 3    | c    | m    |
| 3 | d |     | 4 | p |     | 3    | c    | n    |
+-------+     +-------+     | 3    | d    | m    |
                            | 3    | d    | n    |
                            | 4    | NULL | p    |
                            +--------------------+
*/
```

This query performs a **FULL JOIN** on the `Roster` and `TeamMascot` tables.

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster FULL JOIN TeamMascot ON Roster.SchoolID = TeamMascot.SchoolID;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Buchanan   | Lakers       |
 | Coolidge   | Lakers       |
 | Davis      | Knights      |
 | Eisenhower | NULL         |
 | NULL       | Mustangs     |
 *---------------------------*/
```
###### Left \[Outer\] Join
simply **LEFT JOIN** returns a result that retains all the rows from the left table even if there are no matching rows from the right table. (they become `NULL`) 

```sql
FROM A LEFT OUTER JOIN B ON A.w = B.y

/*
Table A       Table B       Result
+-------+     +-------+     +---------------------------+
| w | x |  *  | y | z |  =  | w    | x    | y    | z    |
+-------+     +-------+     +---------------------------+
| 1 | a |     | 2 | k |     | 1    | a    | NULL | NULL |
| 2 | b |     | 3 | m |     | 2    | b    | 2    | k    |
| 3 | c |     | 3 | n |     | 3    | c    | 3    | m    |
| 3 | d |     | 4 | p |     | 3    | c    | 3    | n    |
+-------+     +-------+     | 3    | d    | 3    | m    |
                            | 3    | d    | 3    | n    |
                            +---------------------------+
*/
```

```sql
FROM A LEFT OUTER JOIN B USING (x)

/*
Table A       Table B       Result
+-------+     +-------+     +--------------------+
| x | y |  *  | x | z |  =  | x    | y    | z    |
+-------+     +-------+     +--------------------+
| 1 | a |     | 2 | k |     | 1    | a    | NULL |
| 2 | b |     | 3 | m |     | 2    | b    | k    |
| 3 | c |     | 3 | n |     | 3    | c    | m    |
| 3 | d |     | 4 | p |     | 3    | c    | n    |
+-------+     +-------+     | 3    | d    | m    |
                            | 3    | d    | n    |
                            +--------------------+
*/
```

This query performs a **LEFT JOIN** on the `Roster` and `TeamMascot` tables.

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster LEFT JOIN TeamMascot ON Roster.SchoolID = TeamMascot.SchoolID;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Buchanan   | Lakers       |
 | Coolidge   | Lakers       |
 | Davis      | Knights      |
 | Eisenhower | NULL         |
 *---------------------------*/
```
###### Right \[Outer\] Join
This is just the **LEFT JOIN** but to the other side, as the name says, for the right table.

This query performs a **RIGHT JOIN** on the `Roster` and `TeamMascot` tables.

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster RIGHT JOIN TeamMascot ON Roster.SchoolID = TeamMascot.SchoolID;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Buchanan   | Lakers       |
 | Coolidge   | Lakers       |
 | Davis      | Knights      |
 | NULL       | Mustangs     |
 *---------------------------*/
```
###### Join conditions
In a join operation, a join condition helps specify how to combine the rows between the tables.

There are 2 ways to join tables:
- **ON** clause
	- Given a row from each table, if the on clause evaluates TRUE, the query generates a row with the two rows combined together. If false on the other hand, then there are different outcomes for the different joins:
		- **INNER JOIN**: both rows from both tables won't be shown
		- **CROSS JOIN**: they will all be shown with `NULL`s on matchless rows
		- **LEFT JOIN**: only the rows from the left table will be fully shown with `NULL`s on matchless rows
		- **RIGHT JOIN**: only the rows from the right table will be fully shown with `NULL`s on matchless rows
	- if a column-order sensitive operation, such as **UNION** or **SELECT** \*, is used with the **ON** join condition, the resulting table contains all of the columns from the left-hand input in order, and then all of the columns from the right-hand input in order.
Ex.
```sql
WITH
  A AS ( SELECT 1 as x UNION ALL SELECT 2 UNION ALL SELECT 3),
  B AS ( SELECT 2 as x UNION ALL SELECT 3 UNION ALL SELECT 4)
SELECT * FROM A INNER JOIN B ON A.x = B.x;

WITH
  A AS ( SELECT 1 as x UNION ALL SELECT 2 UNION ALL SELECT 3),
  B AS ( SELECT 2 as x UNION ALL SELECT 3 UNION ALL SELECT 4)
SELECT A.x, B.x FROM A INNER JOIN B ON A.x = B.x;

/*
Table A   Table B   Result (A.x, B.x)
+---+     +---+     +-------+
| x |  *  | x |  =  | x | x |
+---+     +---+     +-------+
| 1 |     | 2 |     | 2 | 2 |
| 2 |     | 3 |     | 3 | 3 |
| 3 |     | 4 |     +-------+
+---+     +---+
*/
```

```sql
WITH
  A AS ( SELECT 1 as x UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT NULL),
  B AS ( SELECT 2 as x UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5)
SELECT * FROM A LEFT OUTER JOIN B ON A.x = B.x;

WITH
  A AS ( SELECT 1 as x UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT NULL),
  B AS ( SELECT 2 as x UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5)
SELECT A.x, B.x FROM A LEFT OUTER JOIN B ON A.x = B.x;

/*
Table A    Table B   Result
+------+   +---+     +-------------+
| x    | * | x |  =  | x    | x    |
+------+   +---+     +-------------+
| 1    |   | 2 |     | 1    | NULL |
| 2    |   | 3 |     | 2    | 2    |
| 3    |   | 4 |     | 3    | 3    |
| NULL |   | 5 |     | NULL | NULL |
+------+   +---+     +-------------+
*/
```

- **USING** clause
	- **USING** performs an equality comparison operation on the columns name in the `column_name_list`.
	- Each column name in the list have to be in both tables and for each pair of rows from the tables, if the equality returns TRUE then one row is added to the end result column
	- A `NULL` is considered false like in the other cases
	- If a column-order sensitive operation such as `UNION` or `SELECT *` is used with the `USING` join condition, the resulting table contains columns in this order:
		- The columns from `column_name_list` in the order they appear in the `USING` clause.
		- All other columns of the left-hand input in the order they appear in the input.
		- All other columns of the right-hand input in the order they appear in the input.
	- A column name in the `USING` clause must not be qualified by a table name.`
		- If the join is an **INNER** or **LEFT** **JOIN** then the output columns are populated from the values in the left table
		- If the join is a **RIGHT JOIN** then from the right table
		- If it is an **FULL JOIN** then it is populated by **COALESCING** (gets the first value that is not null) the values from the left then the right table
		
```
USING ( column_name_list )

column_name_list:
    column_name[, ...]
```

Ex.

```sql
WITH
  A AS ( SELECT 1 as x UNION ALL SELECT 2 UNION ALL SELECT 9 UNION ALL SELECT NULL),
  B AS ( SELECT 2 as x UNION ALL SELECT 9 UNION ALL SELECT 9 UNION ALL SELECT 5)
SELECT * FROM A INNER JOIN B USING (x);

/*
Table A    Table B   Result
+------+   +---+     +---+
| x    | * | x |  =  | x |
+------+   +---+     +---+
| 1    |   | 2 |     | 2 |
| 2    |   | 9 |     | 9 |
| 9    |   | 9 |     | 9 |
| NULL |   | 5 |     +---+
+------+   +---+
*/
```

```sql
WITH
  A AS (
    SELECT 1 as x, 15 as y UNION ALL
    SELECT 2, 10 UNION ALL
    SELECT 9, 16 UNION ALL
    SELECT NULL, 12),
  B AS (
    SELECT 2 as x, 10 as y UNION ALL
    SELECT 9, 17 UNION ALL
    SELECT 9, 16 UNION ALL
    SELECT 5, 15)
SELECT * FROM A INNER JOIN B USING (x, y);

/*
Table A         Table B        Result
+-----------+   +---------+     +---------+
| x    | y  | * | x  | y  |  =  | x  | y  |
+-----------+   +---------+     +---------+
| 1    | 15 |   | 2  | 10 |     | 2  | 10 |
| 2    | 10 |   | 9  | 17 |     | 9  | 16 |
| 9    | 16 |   | 9  | 16 |     +---------+
| NULL | 12 |   | 5  | 15 |
+-----------+   +---------+
*/
```

```sql
WITH
  A AS ( SELECT 1 as x UNION ALL SELECT 2 UNION ALL SELECT 9 UNION ALL SELECT NULL),
  B AS ( SELECT 2 as x UNION ALL SELECT 9 UNION ALL SELECT 9 UNION ALL SELECT 5)
SELECT x, A.x, B.x FROM A LEFT OUTER JOIN B USING (x)

/*
Table A    Table B   Result
+------+   +---+     +--------------------+
| x    | * | x |  =  | x    | A.x  | B.x  |
+------+   +---+     +--------------------+
| 1    |   | 2 |     | 1    | 1    | NULL |
| 2    |   | 9 |     | 2    | 2    | 2    |
| 9    |   | 9 |     | 9    | 9    | 9    |
| NULL |   | 5 |     | 9    | 9    | 9    |
+------+   +---+     | NULL | NULL | NULL |
                     +--------------------+
*/
```

```sql
WITH
  A AS ( SELECT 1 as x UNION ALL SELECT 2 UNION ALL SELECT 2 UNION ALL SELECT NULL),
  B AS ( SELECT 2 as x UNION ALL SELECT 9 UNION ALL SELECT 9 UNION ALL SELECT 5)
SELECT x, A.x, B.x FROM A RIGHT OUTER JOIN B USING (x)

/*
Table A    Table B   Result
+------+   +---+     +--------------------+
| x    | * | x |  =  | x    | A.x  | B.x  |
+------+   +---+     +--------------------+
| 1    |   | 2 |     | 2    | 2    | 2    |
| 2    |   | 9 |     | 2    | 2    | 2    |
| 2    |   | 9 |     | 9    | NULL | 9    |
| NULL |   | 5 |     | 9    | NULL | 9    |
+------+   +---+     | 5    | NULL | 5    |
                     +--------------------+
*/
```

```sql
WITH
  A AS ( SELECT 1 as x UNION ALL SELECT 2 UNION ALL SELECT 2 UNION ALL SELECT NULL),
  B AS ( SELECT 2 as x UNION ALL SELECT 9 UNION ALL SELECT 9 UNION ALL SELECT 5)
SELECT x, A.x, B.x FROM A FULL OUTER JOIN B USING (x);

/*
Table A    Table B   Result
+------+   +---+     +--------------------+
| x    | * | x |  =  | x    | A.x  | B.x  |
+------+   +---+     +--------------------+
| 1    |   | 2 |     | 1    | 1    | NULL |
| 2    |   | 9 |     | 2    | 2    | 2    |
| 2    |   | 9 |     | 2    | 2    | 2    |
| NULL |   | 5 |     | NULL | NULL | NULL |
+------+   +---+     | 9    | NULL | 9    |
                     | 9    | NULL | 9    |
                     | 5    | NULL | 5    |
                     +--------------------+
*/
```

```sql
WITH
  A AS (
    SELECT 1 as x, 15 as y UNION ALL
    SELECT 2, 10 UNION ALL
    SELECT 9, 16 UNION ALL
    SELECT NULL, 12),
  B AS (
    SELECT 2 as x, 10 as y UNION ALL
    SELECT 9, 17 UNION ALL
    SELECT 9, 16 UNION ALL
    SELECT 5, 15)
SELECT * FROM A INNER JOIN B USING (x);

/*
Table A         Table B         Result
+-----------+   +---------+     +-----------------+
| x    | y  | * | x  | y  |  =  | x   | A.y | B.y |
+-----------+   +---------+     +-----------------+
| 1    | 15 |   | 2  | 10 |     | 2   | 10  | 10  |
| 2    | 10 |   | 9  | 17 |     | 9   | 16  | 17  |
| 9    | 16 |   | 9  | 16 |     | 9   | 16  | 16  |
| NULL | 12 |   | 5  | 15 |     +-----------------+
+-----------+   +---------+
*/
```
###### Multi join operations
It is possible to concatenate multiple join operations:

```sql
FROM A JOIN B USING (x) JOIN C USING (x)

-- A JOIN B USING (x)        = result_1
-- result_1 JOIN C USING (x) = result_2
-- result_2                  = return value
```

Cleaner version:

```sql
FROM ( (A JOIN B USING (x)) JOIN C USING (x) )

-- A JOIN B USING (x)        = result_1
-- result_1 JOIN C USING (x) = result_2
-- result_2                  = return value
```

Or you can join tables in different orders:

```sql
FROM ( A JOIN (B JOIN C USING (x)) USING (x) )

-- B JOIN C USING (x)       = result_1
-- A JOIN result_1          = result_2
-- result_2                 = return value
```

This means that you can also add more than one join condition, USE THE FUCKING PARENTHESIS, otherwise there are gonna be problems and it is gonna be impossible to read:

```sql
FROM A JOIN B JOIN C JOIN D USING (w) ON B.x = C.y ON A.z = B.x
```

```sql
FROM A, B JOIN C JOIN D ON C.x = D.y ON B.z = C.x    // INVALID
```

```sql 
FROM A, B JOIN (C JOIN D ON C.x = D.y) ON B.z = C.x  // VALID
```

When comma cross joins are present in a query with a sequence of JOINs, they group from left to right like other `JOIN` types:

```sql
FROM A JOIN B USING (x) JOIN C USING (x), D

-- A JOIN B USING (x)        = result_1
-- result_1 JOIN C USING (x) = result_2
-- result_2 CROSS JOIN D     = return value
```

>[!WARNING]
>There cannot be a `RIGHT JOIN` or `FULL JOIN` after a comma cross join unless it is parenthesized.

```sql
FROM A, B RIGHT JOIN C ON TRUE -- INVALID
```

```sql
FROM A, (B RIGHT JOIN C ON TRUE) -- VALID
```
##### Union operator
The **UNION** operator combines the result set of two or more **SELECT** statements by pairing columns form the result set of each **SELECT** statement and vertically concatenating them.

```sql
SELECT Mascot AS X, SchoolID AS Y
FROM TeamMascot
UNION ALL
SELECT LastName, PointsScored
FROM PlayerStats;
```

Results:

| X        | Y   |
| -------- | --- |
| Jaguars  | 50  |
| Knights  | 51  |
| Lakers   | 52  |
| Mustangs | 53  |
| Adams    | 3   |
| Buchanan | 0   |
| Coolidge | 1   |
| Adams    | 4   |
| Buchanan | 13  |
![[Screenshot 2025-01-14 091610.png]]
#### Unnest Operator
```
unnest_operator:
  {
    UNNEST( array ) [ as_alias ]
    | array_path [ as_alias ]
  }
  [ WITH OFFSET [ as_alias ] ]

array:
  { array_expression | array_path }

as_alias:
  [AS] alias
```

The **UNNEST OPERATOR** takes an array and returns a table with one row for each element in the array. The output of the operation is a value table. For these array element types, **SELECT** \* against the value table column returns multiple columns: **STRUCT**

input values:

- `array_expression`: An expression that produces an array.
- `array_path`: The path to an `ARRAY` type.
    - In an implicit `UNNEST` operation, the path must start with a range variable name.
    - In an explicit `UNNEST` operation, the path can optionally start with a range variable name.
- **WITH OFFSET**: **UNNEST** destroys the order of elements in the input array. Use this optional clause to return an additional column with the array element indexes, or offsets. It starts at 0 for each **UNNEST** operation. 

```sql
SELECT * FROM UNNEST ([10,20,30]) as numbers WITH OFFSET;

/*---------+--------*
 | numbers | offset |
 +---------+--------+
 | 10      | 0      |
 | 20      | 1      |
 | 30      | 2      |
 *---------+--------*/
```

You can also use **UNNEST** outside the **FROM** clause with the **IN** operator.
##### Unnest and Structs
For and input array of structs, **UNNEST** returns a row for each struct, with a separate column for each field in the struct. The alias for each column is the name of the corresponding struct field.

```sql
SELECT *
FROM UNNEST(
  ARRAY<
    STRUCT<
      x INT64,
      y STRING,
      z STRUCT<a INT64, b INT64>>>[
        (1, 'foo', (10, 11)),
        (3, 'bar', (20, 21))]);

/*---+-----+----------*
 | x | y   | z        |
 +---+-----+----------+
 | 1 | foo | {10, 11} |
 | 3 | bar | {20, 21} |
 *---+-----+----------*/
```

Because the **UNNEST** operator returns a value table, you can alias **UNNEST** to define a range variable that you can reference elsewhere in the query.

```sql
SELECT *, struct_value
FROM UNNEST(
  ARRAY<
    STRUCT<
    x INT64,
    y STRING>>[
      (1, 'foo'),
      (3, 'bar')]) AS struct_value;

/*---+-----+--------------*
 | x | y   | struct_value |
 +---+-----+--------------+
 | 3 | bar | {3, bar}     |
 | 1 | foo | {1, foo}     |
 *---+-----+--------------*/
```
##### Explicit and implicit Unnest
Array unnesting can be either explicit or implicit.
- Explicit: the **UNNEST** keyword is required

```sql
WITH Coordinates AS (SELECT [1,2] AS position)
SELECT results FROM Coordinates, UNNEST(Coordinates.position) AS results;
```

- Implicit: the **UNNEST** keyword id not used

```sql
WITH Coordinates AS (SELECT [1,2] AS position)
SELECT results FROM Coordinates, Coordinates.position AS results;
```

The `NULL`s will be treated as empty array and produce 0 rows, but if there is an array containing `NULL` values then it will produce rows with `NULL` values.
#### Where clause
```
WHERE bool_expression
```

The **WHERE** clause filters the result of the **FROM** clause.

Only rows whose `bool_expression` evaluates TRUE are included, the others will be discarded.

```sql
SELECT * FROM Roster
WHERE STARTS_WITH(LastName, "Mc") OR STARTS_WITH(LastName, "Mac");
```
#### Group By clause
```
GROUP BY group_by_specification

group_by_specification:
  {
    groupable_items
    | ALL
    | grouping_sets_specification
    | rollup_specification
    | cube_specification
    | ()
  }
```

The **GROUP BY** clause groups together rows in a table that share common values for certain values. For a group of rows in the source table with non distinct values, the **GROUP BY** clause aggregates them into a single combined row.
- `groupable_items`: Group rows in a table that share common values for certain columns. To learn more.
- `ALL`: Automatically group rows. To learn more.
- `grouping_sets_specification`: Group rows with the `GROUP BY GROUPING SETS` clause. To learn more.
- `rollup_specification`: Group rows with the `GROUP BY ROLLUP` clause. To learn more.
- `cube_specification`: Group rows with the `GROUP BY CUBE` clause. To learn more.
- `()`: Group all rows and produce a grand total. Equivalent to no `group_by_specification`.

Or you can also group by column index (Int64).

##### **GROUP BY** values

```sql
WITH PlayerStats AS (
  SELECT 'Adams' as LastName, 'Noam' as FirstName, 3 as PointsScored UNION ALL
  SELECT 'Buchanan', 'Jie', 0 UNION ALL
  SELECT 'Coolidge', 'Kiran', 1 UNION ALL
  SELECT 'Adams', 'Noam', 4 UNION ALL
  SELECT 'Buchanan', 'Jie', 13)
SELECT SUM(PointsScored) AS total_points, LastName
FROM PlayerStats
GROUP BY LastName;

/*--------------+----------+
 | total_points | LastName |
 +--------------+----------+
 | 7            | Adams    |
 | 13           | Buchanan |
 | 1            | Coolidge |
 +--------------+----------*/
```

You can use the `GROUP BY` clause with arrays. The following query executes because the array elements being grouped are the same length and group type:

```sql
WITH PlayerStats AS (
  SELECT ['Coolidge', 'Adams'] as Name, 3 as PointsScored UNION ALL
  SELECT ['Adams', 'Buchanan'], 0 UNION ALL
  SELECT ['Coolidge', 'Adams'], 1 UNION ALL
  SELECT ['Kiran', 'Noam'], 1)
SELECT SUM(PointsScored) AS total_points, name
FROM PlayerStats
GROUP BY Name;

/*--------------+------------------+
 | total_points | name             |
 +--------------+------------------+
 | 4            | [Coolidge,Adams] |
 | 0            | [Adams,Buchanan] |
 | 1            | [Kiran,Noam]     |
 +--------------+------------------*/
```

You can use the `GROUP BY` clause with structs. The following query executes because the struct fields being grouped have the same group types:

```sql
WITH
  TeamStats AS (
    SELECT
      ARRAY<STRUCT<last_name STRING, first_name STRING, age INT64>>[
        ('Adams', 'Noam', 20), ('Buchanan', 'Jie', 19)] AS Team,
      3 AS PointsScored
    UNION ALL
    SELECT [('Coolidge', 'Kiran', 21), ('Yang', 'Jason', 22)], 4
    UNION ALL
    SELECT [('Adams', 'Noam', 20), ('Buchanan', 'Jie', 19)], 10
    UNION ALL
    SELECT [('Coolidge', 'Kiran', 21), ('Yang', 'Jason', 22)], 7
  )
SELECT
  SUM(PointsScored) AS total_points,
  Team
FROM TeamStats
GROUP BY Team;

/*--------------+--------------------------+
 | total_points | teams                    |
 +--------------+--------------------------+
 | 13           | [{                       |
 |              |    last_name: "Adams",   |
 |              |    first_name: "Noam",   |
 |              |    age: 20               |
 |              |  },{                     |
 |              |    last_name: "Buchanan",|
 |              |    first_name: "Jie",    |
 |              |    age: 19               |
 |              |  }]                      |
 +-----------------------------------------+
 | 11           | [{                       |
 |              |    last_name: "Coolidge",|
 |              |    first_name: "Kiran",  |
 |              |    age: 21               |
 |              |  },{                     |
 |              |    last_name: "Yang",    |
 |              |    first_name: "Jason",  |
 |              |    age: 22               |
 |              |  }]                      |
 +--------------+--------------------------*/
```
##### **GROUP BY** all
The **GROUP BY ALL** clause groups rows by inferring grouping keys from the select times. The items that are excluded are:
- Items that are aggregated
- Items that are included in a window function
- Items that do not reference a name from the **FROM** clause, including:
	- Constants
	- Query parameters
	- Correlated column references
	- Expressions that only reference `GROUP BY` keys inferred from other `SELECT` items.

Ex.

```sql
WITH PlayerStats AS (
  SELECT 'Adams' as LastName, 'Noam' as FirstName, 3 as PointsScored UNION ALL
  SELECT 'Buchanan', 'Jie', 0 UNION ALL
  SELECT 'Coolidge', 'Kiran', 1 UNION ALL
  SELECT 'Adams', 'Noam', 4 UNION ALL
  SELECT 'Buchanan', 'Jie', 13)
SELECT
  SUM(PointsScored) AS total_points,
  FirstName AS first_name,
  LastName AS last_name
FROM PlayerStats
GROUP BY ALL;

/*--------------+------------+-----------+
 | total_points | first_name | last_name |
 +--------------+------------+-----------+
 | 7            | Noam       | Adams     |
 | 13           | Jie        | Buchanan  |
 | 1            | Kiran      | Coolidge  |
 +--------------+------------+-----------*/
```

If multiple `SELECT` items reference the same `FROM` item, and any of them is a path expression prefix of another, only the prefix path is used for grouping. In the following example, `coordinates` is excluded because `x_coordinate` and `y_coordinate` have already referenced `Values.x` and `Values.y` in the `FROM` clause, and they are prefixes of the path expression used in `x_coordinate`:

```sql
WITH Values AS (
  SELECT 1 AS x, 2 AS y
  UNION ALL SELECT 1 AS x, 4 AS y
  UNION ALL SELECT 2 AS x, 5 AS y
)
SELECT
  Values.x AS x_coordinate,
  Values.y AS y_coordinate,
  [Values.x, Values.y] AS coordinates
FROM Values
GROUP BY ALL

/*--------------+--------------+-------------+
 | x_coordinate | y_coordinate | coordinates |
 +--------------+--------------+-------------+
 | 1            | 4            | [1, 4]      |
 | 1            | 2            | [1, 2]      |
 | 2            | 5            | [2, 5]      |
 +--------------+--------------+-------------*/
```
##### GROUPING sets
```
GROUP BY GROUPING SETS ( grouping_list )

grouping_list:
  {
    rollup_specification
    | cube_specification
    | groupable_item
    | groupable_item_set
  }[, ...]

groupable_item_set:
  ( [ groupable_item[, ...] ] )
```

The **GROUP BY GROUPING SETS** clause produces aggregated data for one or more grouping sets. A grouping set is a group of columns by which rows can be grouped together. This is helpful if you want to produce aggregated data without using **UNION**.

For example, `GROUP BY GROUPING SETS(x,y)` is roughly equivalent to `GROUP BY x UNION ALL GROUP BY y`.

**Definitions**

- `grouping_list`: A list of items that you can add to the `GROUPING SETS` clause. Grouping sets are generated based upon what is in this list.
- `rollup_specification`: Group rows with the `ROLLUP` clause. Don't include `GROUP BY` if you use this inside the `GROUPING SETS` clause.
- `cube_specification`: Group rows with the `CUBE` clause. Don't include `GROUP BY` if you use this inside the `GROUPING SETS` clause. 
- `groupable_item`: Group rows in a table that share common values for certain columns. To learn more. Anonymous `STRUCT` values are not allowed.
- `groupable_item_set`: Group rows by a set of groupable items. If the set contains no groupable items, group all rows and produce a grand total.

