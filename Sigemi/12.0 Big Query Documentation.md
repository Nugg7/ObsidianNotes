### Syntax
---
Query statements scan one or more tables or expressions and return a single table containing the result of the query (similar, if not the same, as the one in basic SQL).
#### Notation rules
In the documentation of google SQL (Big Query), the code is usually described through some notations as these ones:
- [] -> Optional Clause
- {a | b | c} -> logical `OR` (choose one of them)
- ... -> the item preceding them can repeat
- "" -> syntax inside them is required

```bq
SELECT
	[WITH Differential_Privacy_clause/s]
	[{ALL | DISTINCT}]
	[AS {STRUCT | VALUE}]
	select_list

- select_list:
	- {select_all | select_expresstion} [, ...]
		- select_all:
			- [expression]*
			- [EXCEPT (column_name [, ...])]
			- [REPLACE (expression as column_name [, ...])]
		- select_expression:
			- expression [[AS] alias]
```

It's practically the same as the one in SQL, * meaning all, and every little quirk like: 

Ex.
```sql
SELECT * FROM (
	SELECT 
		"apple" AS fruit, 
		"carrot" AS vegetable
)

-- output:

/*-------+-----------*
 | fruit | vegetable |
 +-------+-----------+
 | apple | carrot    |
 *-------+-----------*/
```
#### Select Expression
Then we have the **select expression**, these expressions evaluate to a single value and produce one output column with an optional explicit `alias`.
##### Select Expression.*
An item in the select list can also take the form of `expression.*`. This produces one output column for each column or top level field of expression. It has to be either a table alias or evaluate to a single value of data type with fields like structs.

Ex.
``` sql
WITH groceries AS
  (SELECT "milk" AS dairy,
   "eggs" AS protein,
   "bread" AS grain)
SELECT g.*
FROM groceries AS g;

/*-------+---------+-------*
 | dairy | protein | grain |
 +-------+---------+-------+
 | milk  | eggs    | bread |
 *-------+---------+-------*/
-- or
WITH locations AS
  (SELECT STRUCT("Seattle" AS city, "Washington" AS state) AS location
  UNION ALL
  SELECT STRUCT("Phoenix" AS city, "Arizona" AS state) AS location)
SELECT l.location.*
FROM locations l;

/*---------+------------*
 | city    | state      |
 +---------+------------+
 | Seattle | Washington |
 | Phoenix | Arizona    |
 *---------+------------*/
 -- or
WITH locations AS
  (SELECT ARRAY<STRUCT<city STRING, state STRING>>[("Seattle", "Washington"),
    ("Phoenix", "Arizona")] AS location)
SELECT l.LOCATION[offset(0)].*
FROM locations l;

/*---------+------------*
 | city    | state      |
 +---------+------------+
 | Seattle | Washington |
 *---------+------------*/
```
##### Select * Replace
A **SELECT * REPLACE** statement specifies one or more `expression as identifier` clauses. Each identifier used must match a column name from the **SELECT \*** statement. The output column list that matches the identifier in a **REPLACE**  clause will replace the instances inside of it.

The replace cannot change the names or the order of the column but it can change the values in them and the value type.

Ex.
```sql
WITH orders AS
  (SELECT 5 as order_id,
  "sprocket" as item_name,
  200 as quantity)
SELECT * REPLACE ("widget" AS item_name)
FROM orders;

/*----------+-----------+----------*
 | order_id | item_name | quantity |
 +----------+-----------+----------+
 | 5        | widget    | 200      |
 *----------+-----------+----------*/

WITH orders AS
  (SELECT 5 as order_id,
  "sprocket" as item_name,
  200 as quantity)
SELECT * REPLACE (quantity/2 AS quantity)
FROM orders;

/*----------+-----------+----------*
 | order_id | item_name | quantity |
 +----------+-----------+----------+
 | 5        | sprocket  | 100      |
 *----------+-----------+----------*/
```
##### Select Distinct
A **SELECT DISTINCT** statement discards duplicate rows but cannot return columns of the following type:

In the following example, `SELECT DISTINCT` is used to produce distinct arrays:
```sql
WITH PlayerStats AS (
  SELECT ['Coolidge', 'Adams'] as Name, 3 as PointsScored UNION ALL
  SELECT ['Adams', 'Buchanan'], 0 UNION ALL
  SELECT ['Coolidge', 'Adams'], 1 UNION ALL
  SELECT ['Kiran', 'Noam'], 1)
SELECT DISTINCT Name

/*------------------+
 | Name             |
 +------------------+
 | [Coolidge,Adams] |
 | [Adams,Buchanan] |
 | [Kiran,Noam]     |
 +------------------*/
```

In the following example, it is used to create distinct structs:
```sql
WITH
  PlayerStats AS (
    SELECT
      STRUCT<last_name STRING, first_name STRING, age INT64>(
        'Adams', 'Noam', 20) AS Player,
      3 AS PointsScored UNION ALL
    SELECT ('Buchanan', 'Jie', 19), 0 UNION ALL
    SELECT ('Adams', 'Noam', 20), 4 UNION ALL
    SELECT ('Buchanan', 'Jie', 19), 13
  )
SELECT DISTINCT Player
FROM PlayerStats;

/*--------------------------+
 | player                   |
 +--------------------------+
 | {                        |
 |   last_name: "Adams",    |
 |   first_name: "Noam",    |
 |   age: 20                |
 |  }                       |
 +--------------------------+
 | {                        |
 |   last_name: "Buchanan", |
 |   first_name: "Jie",     |
 |   age: 19                |
 |  }                       |
 +---------------------------*/
```
##### Select All
The **SELECT ALL** statement returns all rows, including duplicating ones and it is the default behavior of the **SELECT**.
##### Select As Struct
```sql
SELECT AS STRUCT expr [[AS] struct_field_name1] [,...]
```

This produces a [value table](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#value_tables) with a STRUCT row type, where the STRUCT field names and types match the column names and types produced in the `SELECT` list.

Ex.
```sql
SELECT ARRAY(SELECT AS STRUCT 1 a, 2 b)
```

In this example we can see that it can be used in a **scalar** or **array** subquery in order to produce a single struct containing all the grouped values together. (**scalar** and **array** subqueries cannot return multiple columns but can return multiple data grouped a single struct as a single column)

Ex.
Array subquery
```sql
SELECT
  ARRAY(SELECT username FROM NPCs WHERE team = 'red') AS red;

/*-----------------*
 | red             |
 +-----------------+
 | [niles,jujul]   |
 *-----------------*/
```

Scalar subquery
```sql
SELECT
  username,
  (SELECT mascot FROM Mascots WHERE Players.team = Mascots.team) AS player_mascot
FROM
  Players;

/*---------------------------*
 | username  | player_mascot |
 +---------------------------+
 | gorbie    | cardinal      |
 | junelyn   | finch         |
 | corba     | parrot        |
 *---------------------------*/
```
##### Select As Value
**SELECT As VALUE** produces a value table from any **select list that produces exactly one column**. Instead of producing an output table with only one column, the output will be a value table where the row type is the value type that was produced in one select column. **Any aliases the column had will be discarded in the value table.**
##### Value tables
In addition to normal tables in SQL, BQ also has value tables, where every row is a single value of type **STRUCT** and there are no column names.

Ex.
```sql
SELECT * FROM (SELECT AS VALUE STRUCT(123 AS a, FALSE AS b))

/*-----+-------*
 | a   | b     |
 +-----+-------+
 | 123 | FALSE |
 *-----+-------*/
```
#### From Clause
```
FROM from_clause[, ...]

from_clause:
	- from_item
	- [{pivot_operator | unipivot_operator}]
	- [tablesample_operator]
		- from_item:
			{
				table_name [as alias] [FOR SYSTEM_TIME AS OF timespamp_expression] |
				{join_operation | (join_operation)} |
				(query_expression) [as alias] |
				field_path |
				unnest_operator |
				cte_name [as alias]
			}
```

The **FROM** clause indicates the table or tables from which to retrieve data, and specifies how to join the data from the tables if 2 or more to produce a single stream of rows.
##### `For System_Time As Of`
**FOR SYSTEM_TIME AS OF** references the historical versions of the table definition and rows that were current at `timestamp_expresssion`.

Limitations: 
- The source table in the **FROM** clause containing **FOR SYSTEM_TIME AS OF** must not be any of the following:
	- Subqueries.
	- Correlated references (references to columns of a table that appear at a higher level of the query statement, such as in the `SELECT` list).
	- User-defined functions (UDFs).
- The value of `timestamp_expresssion` cannot fall in the following ranges:
	- After the current timestamp (in the future).
	- More than 7 days before the current timestamp.
- A single query statement cannot reference a single table at more than one point in time, including the current time.
The default time zone for `timestamp_expresssion` in **FOR SYSTEM_TIME AS OF** is `America/Los_Angeles`, even though the default time zones for timestamp literals is `UTC`. 

EX.
```sql
SELECT *
FROM t
  FOR SYSTEM_TIME AS OF TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 HOUR);
```

```sql
SELECT *
FROM t
  FOR SYSTEM_TIME AS OF '2017-01-01 10:00:00-07:00';
```

```sql
SELECT *
FROM t1
WHERE t1.a IN (SELECT t2.a
               FROM t2 FOR SYSTEM_TIME AS OF t1.timestamp_column);
```

The following operations show accessing a historical version of the table before table is replaced.

```sql
DECLARE before_replace_timestamp TIMESTAMP;

-- Create table books.
CREATE TABLE books AS
SELECT 'Hamlet' title, 'William Shakespeare' author;

-- Get current timestamp before table replacement.
SET before_replace_timestamp = CURRENT_TIMESTAMP();

-- Replace table with different schema(title and release_date).
CREATE OR REPLACE TABLE books AS
SELECT 'Hamlet' title, DATE '1603-01-01' release_date;

-- This query returns Hamlet, William Shakespeare as result.
SELECT * FROM books FOR SYSTEM_TIME AS OF before_replace_timestamp;
```

The following operations show accessing a historical version of the table before a DML job.

```sql
DECLARE JOB_START_TIMESTAMP TIMESTAMP;

-- Create table books.
CREATE OR REPLACE TABLE books AS
SELECT 'Hamlet' title, 'William Shakespeare' author;

-- Insert two rows into the books.
INSERT books (title, author)
VALUES('The Great Gatsby', 'F. Scott Fizgerald'),
      ('War and Peace', 'Leo Tolstoy');

SELECT * FROM books;

SET JOB_START_TIMESTAMP = (
  SELECT start_time
  FROM `region-us`.INFORMATION_SCHEMA.JOBS_BY_USER
  WHERE job_type="QUERY"
    AND statement_type="INSERT"
  ORDER BY start_time DESC
  LIMIT 1
 );

-- This query only returns Hamlet, William Shakespeare as result.
SELECT * FROM books FOR SYSTEM_TIME AS OF JOB_START_TIMESTAMP;
```

The following query returns an error because the DML operates on the current version of the table, and a historical version of the table from one day ago.

```sql
INSERT INTO t1
SELECT * FROM t1
  FOR SYSTEM_TIME AS OF TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 DAY);
```
##### Pivot operator
```
From from_item[, ...] pivot_operator
	
- pivot_operator:
	PIVOT(
		aggregate_function_call [as alias][, ...]
		For input_column
		In (pivot_column [as alias][, ...])
		) [as alias]
```

The **PIVOT** Operator rotates rows into columns, using an aggregation. Pivot is part of the **FROM** clause.
- **PIVOT** can be used to modify any table expression
- Combining **PIVOT** with **FOR SYSTEM_TIME AS OF** is not allowed, although users may use **PIVOT** against a subquery input which itself uses **FOR SYSTEM_TIME AS OF**.
- A **WITH OFFSET** clause immediately preceding the **PIVOT** operator is not allowed.

Conceptual example:
```
-- Before PIVOT is used to rotate sales and quarter into Q1, Q2, Q3, Q4 columns:
/*---------+-------+---------+------*
 | product | sales | quarter | year |
 +---------+-------+---------+------|
 | Kale    | 51    | Q1      | 2020 |
 | Kale    | 23    | Q2      | 2020 |
 | Kale    | 45    | Q3      | 2020 |
 | Kale    | 3     | Q4      | 2020 |
 | Kale    | 70    | Q1      | 2021 |
 | Kale    | 85    | Q2      | 2021 |
 | Apple   | 77    | Q1      | 2020 |
 | Apple   | 0     | Q2      | 2020 |
 | Apple   | 1     | Q1      | 2021 |
 *---------+-------+---------+------*/

-- After PIVOT is used to rotate sales and quarter into Q1, Q2, Q3, Q4 columns:
/*---------+------+----+------+------+------*
 | product | year | Q1 | Q2   | Q3   | Q4   |
 +---------+------+----+------+------+------+
 | Apple   | 2020 | 77 | 0    | NULL | NULL |
 | Apple   | 2021 | 1  | NULL | NULL | NULL |
 | Kale    | 2020 | 51 | 23   | 45   | 3    |
 | Kale    | 2021 | 70 | 85   | NULL | NULL |
 *---------+------+----+------+------+------*/
```

*// the Definition of the entire thing with the practical examples will come later*.
##### Unpivot operator
```
FROM from_item[, ...] unpivot_operator

unpivot_operator:
  UNPIVOT [ { INCLUDE NULLS | EXCLUDE NULLS } ] (
    { single_column_unpivot | multi_column_unpivot }
  ) [unpivot_alias]

single_column_unpivot:
  values_column
  FOR name_column
  IN (columns_to_unpivot)

multi_column_unpivot:
  values_column_set
  FOR name_column
  IN (column_sets_to_unpivot)

values_column_set:
  (values_column[, ...])

columns_to_unpivot:
  unpivot_column [row_value_alias][, ...]

column_sets_to_unpivot:
  (unpivot_column [row_value_alias][, ...])

unpivot_alias and row_value_alias:
  [AS] alias
```

The **UNPIVOT** operator rotates the columns into rows ad is part of the **FROM** clause.
- **UNPIVOT** can be used to modify any table expression.
- Combining **UNPIVOT** with **FOR SYSTEM_TIME AS OF** is not allowed, although users may use **UNPIVOT** against a subquery input which itself uses **FOR SYSTEM_TIME AS OF**.
- A **WITH OFFSET** clause immediately preceding the **UNPIVOT** operator is not allowed.
- **PIVOT** aggregations cannot be reversed with **UNPIVOT**.

Conceptual example:
```
-- Before UNPIVOT is used to rotate Q1, Q2, Q3, Q4 into sales and quarter columns:
/*---------+----+----+----+----*
 | product | Q1 | Q2 | Q3 | Q4 |
 +---------+----+----+----+----+
 | Kale    | 51 | 23 | 45 | 3  |
 | Apple   | 77 | 0  | 25 | 2  |
 *---------+----+----+----+----*/

-- After UNPIVOT is used to rotate Q1, Q2, Q3, Q4 into sales and quarter columns:
/*---------+-------+---------*
 | product | sales | quarter |
 +---------+-------+---------+
 | Kale    | 51    | Q1      |
 | Kale    | 23    | Q2      |
 | Kale    | 45    | Q3      |
 | Kale    | 3     | Q4      |
 | Apple   | 77    | Q1      |
 | Apple   | 0     | Q2      |
 | Apple   | 25    | Q3      |
 | Apple   | 2     | Q4      |
 *---------+-------+---------*/
```

*// the Definition of the entire thing with the practical examples will come later*.
##### Table sample operator
```
TABLESAMPLE SYSTEM ( percent PERCENT )
```

You can use the **TABLESAMPLE** operator to select a random sample of a dataset. (Practically a random picker from a large batch of files)

Sampling returns a variety of records while avoiding the costs of scanning and processing the entire table. (the results of queries that contain **TABLESAMPLE** are not cached since it returns something different every time)

*// more information in the next chapters*

Ex.
This query selects approximately 10% of the table's data randomly. 
```sql
SELECT * FROM dataset.my_table TABLESAMPLE SYSTEM (10 PERCENT)
```
##### Join operator
```
oin_operation:
  { cross_join_operation | condition_join_operation }

cross_join_operation:
  from_item cross_join_operator from_item
  
condition_join_operation:
  from_item condition_join_operator from_item join_condition

cross_join_operator:
  { CROSS JOIN | , }

condition_join_operator:
  {
    [INNER] JOIN
    | FULL [OUTER] JOIN
    | LEFT [OUTER] JOIN
    | RIGHT [OUTER] JOIN
  }

join_condition:
  { on_clause | using_clause }

on_clause:
  ON bool_expression
using_clause:
  USING ( column_list )
```

The **JOIN** Operation merges two `from_item`s so that the **SELECT** clause can query them as one source. The join operator and join condition specify how to combine and discard rows from the `from_item`s to form a single source.
###### \[Inner\] Join
An **INNER JOIN**, or simply **JOIN**, effectively calculates the cartesian product of the 2 `from_item`s discarding the rows that don't meet the join conditions. (gets the elements from the 2 tables and merges only the ones that have an equivalent on the other table)

```sql
FROM A INNER JOIN B ON A.w = B.y

/*
Table A       Table B       Result
+-------+     +-------+     +---------------+
| w | x |  *  | y | z |  =  | w | x | y | z |
+-------+     +-------+     +---------------+
| 1 | a |     | 2 | k |     | 2 | b | 2 | k |
| 2 | b |     | 3 | m |     | 3 | c | 3 | m |
| 3 | c |     | 3 | n |     | 3 | c | 3 | n |
| 3 | d |     | 4 | p |     | 3 | d | 3 | m |
+-------+     +-------+     | 3 | d | 3 | n |
                            +---------------+
*/
```

```sql
FROM A INNER JOIN B USING (x)

/*
Table A       Table B       Result
+-------+     +-------+     +-----------+
| x | y |  *  | x | z |  =  | x | y | z |
+-------+     +-------+     +-----------+
| 1 | a |     | 2 | k |     | 2 | b | k |
| 2 | b |     | 3 | m |     | 3 | c | m |
| 3 | c |     | 3 | n |     | 3 | c | n |
| 3 | d |     | 4 | p |     | 3 | d | m |
+-------+     +-------+     | 3 | d | n |
                            +-----------+
*/
```

###### Cross Join
The **CROSS JOIN** returns the cartesian product of the 2 `from_item`s. in other words, combines each row from the first table to each row of the second. (practically just mushes them together and duplicates the hell out of the rows).

```sql
FROM A CROSS JOIN B

/*
Table A       Table B       Result
+-------+     +-------+     +---------------+
| w | x |  *  | y | z |  =  | w | x | y | z |
+-------+     +-------+     +---------------+
| 1 | a |     | 2 | c |     | 1 | a | 2 | c |
| 2 | b |     | 3 | d |     | 1 | a | 3 | d |
+-------+     +-------+     | 2 | b | 2 | c |
                            | 2 | b | 3 | d |
                            +---------------+
*/
```

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster CROSS JOIN TeamMascot;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Adams      | Knights      |
 | Adams      | Lakers       |
 | Adams      | Mustangs     |
 | Buchanan   | Jaguars      |
 | Buchanan   | Knights      |
 | Buchanan   | Lakers       |
 | Buchanan   | Mustangs     |
 | ...                       |
 *---------------------------*/
```

**CROSS JOIN** can also be written implicitly with a comma. (comma cross join) like:

```sql
FROM A, B

/*
Table A       Table B       Result
+-------+     +-------+     +---------------+
| w | x |  *  | y | z |  =  | w | x | y | z |
+-------+     +-------+     +---------------+
| 1 | a |     | 2 | c |     | 1 | a | 2 | c |
| 2 | b |     | 3 | d |     | 1 | a | 3 | d |
+-------+     +-------+     | 2 | b | 2 | c |
                            | 2 | b | 3 | d |
                            +---------------+
*/
```

You cannot write comma cross joins inside parentheses.

```sql
FROM (A, B)  -- INVALID
```

This query performs a **COMMA CROSS JOIN** on the `Roster` and `TeamMascot` tables.

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster, TeamMascot;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Adams      | Knights      |
 | Adams      | Lakers       |
 | Adams      | Mustangs     |
 | Buchanan   | Jaguars      |
 | Buchanan   | Knights      |
 | Buchanan   | Lakers       |
 | Buchanan   | Mustangs     |
 | ...                       |
 *---------------------------*/
```
###### Full \[Outer\] Join
A **FULL OUTER JOIN** (or simply **FULL JOIN**) returns all fields for all matching rows in both `from_item`s that meet the join condition, if a row does not have a matching row in the other table then it merges it with a new row containing only `NULL`s.

```sql
FROM A FULL OUTER JOIN B ON A.w = B.y

/*
Table A       Table B       Result
+-------+     +-------+     +---------------------------+
| w | x |  *  | y | z |  =  | w    | x    | y    | z    |
+-------+     +-------+     +---------------------------+
| 1 | a |     | 2 | k |     | 1    | a    | NULL | NULL |
| 2 | b |     | 3 | m |     | 2    | b    | 2    | k    |
| 3 | c |     | 3 | n |     | 3    | c    | 3    | m    |
| 3 | d |     | 4 | p |     | 3    | c    | 3    | n    |
+-------+     +-------+     | 3    | d    | 3    | m    |
                            | 3    | d    | 3    | n    |
                            | NULL | NULL | 4    | p    |
                            +---------------------------+
*/
```

```sql
FROM A FULL OUTER JOIN B USING (x)

/*
Table A       Table B       Result
+-------+     +-------+     +--------------------+
| x | y |  *  | x | z |  =  | x    | y    | z    |
+-------+     +-------+     +--------------------+
| 1 | a |     | 2 | k |     | 1    | a    | NULL |
| 2 | b |     | 3 | m |     | 2    | b    | k    |
| 3 | c |     | 3 | n |     | 3    | c    | m    |
| 3 | d |     | 4 | p |     | 3    | c    | n    |
+-------+     +-------+     | 3    | d    | m    |
                            | 3    | d    | n    |
                            | 4    | NULL | p    |
                            +--------------------+
*/
```

This query performs a **FULL JOIN** on the `Roster` and `TeamMascot` tables.

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster FULL JOIN TeamMascot ON Roster.SchoolID = TeamMascot.SchoolID;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Buchanan   | Lakers       |
 | Coolidge   | Lakers       |
 | Davis      | Knights      |
 | Eisenhower | NULL         |
 | NULL       | Mustangs     |
 *---------------------------*/
```
###### Left \[Outer\] Join
simply **LEFT JOIN** returns a result that retains all the rows from the left table even if there are no matching rows from the right table. (they become `NULL`) 

```sql
FROM A LEFT OUTER JOIN B ON A.w = B.y

/*
Table A       Table B       Result
+-------+     +-------+     +---------------------------+
| w | x |  *  | y | z |  =  | w    | x    | y    | z    |
+-------+     +-------+     +---------------------------+
| 1 | a |     | 2 | k |     | 1    | a    | NULL | NULL |
| 2 | b |     | 3 | m |     | 2    | b    | 2    | k    |
| 3 | c |     | 3 | n |     | 3    | c    | 3    | m    |
| 3 | d |     | 4 | p |     | 3    | c    | 3    | n    |
+-------+     +-------+     | 3    | d    | 3    | m    |
                            | 3    | d    | 3    | n    |
                            +---------------------------+
*/
```

```sql
FROM A LEFT OUTER JOIN B USING (x)

/*
Table A       Table B       Result
+-------+     +-------+     +--------------------+
| x | y |  *  | x | z |  =  | x    | y    | z    |
+-------+     +-------+     +--------------------+
| 1 | a |     | 2 | k |     | 1    | a    | NULL |
| 2 | b |     | 3 | m |     | 2    | b    | k    |
| 3 | c |     | 3 | n |     | 3    | c    | m    |
| 3 | d |     | 4 | p |     | 3    | c    | n    |
+-------+     +-------+     | 3    | d    | m    |
                            | 3    | d    | n    |
                            +--------------------+
*/
```

This query performs a **LEFT JOIN** on the `Roster` and `TeamMascot` tables.

```sql
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster LEFT JOIN TeamMascot ON Roster.SchoolID = TeamMascot.SchoolID;

/*---------------------------*
 | LastName   | Mascot       |
 +---------------------------+
 | Adams      | Jaguars      |
 | Buchanan   | Lakers       |
 | Coolidge   | Lakers       |
 | Davis      | Knights      |
 | Eisenhower | NULL         |
 *---------------------------*/
```