### `BigQuery`
---
Un data warehouse e' un ambiente dove si caricano dati elaborati e pronti per l'analisi. Big Query e' un data warehouse in google cloud.

I progetti che abbiamo sono in google cloud per esempio sono quelli di `sigemi-prod`, dove troviamo le risorse per la produzione per i clienti esterni ed interni.

Ci sono i dataset che sono dei raggruppamenti di tabelle, tra cui anche quelle di `**OweB**`. I dataset hanno una `convenzione di nomi`  con `area di competenza del dato _ descrizione`, se c'e' `vw` nel nome sta a significare solo che e' una vista.

Non essendo un db relazionale Big Query, le chiavi primarie che sono specificate, sono solo delle scorciatoie per la ricerca nelle query ma in non sono utilizzate.

Streaming buffer, per le analisi streaming, ovvero operazioni in tempo reale per l'analisi di ogni cambiamento.

Big Query ha delle aggiunte per l'ottimizzazione delle analisi.

L'indice $puo'$ essere visto come meta dato. Le tabelle indicizzate sono per esempio quelle partizionate, ovvero divise in tanti piccoli blocchi che (partizionata per giorni per esempio) equivalgono a ogni giorno .

La cluster-`izzazione` equivale alla stessa cosa ma per altri campi indicizzandoli.

Big query permette di implementare una logica relazionale in una struttura non relazionale, ovvero permette un nesting dei dati dove una riga ha la $possibilita'$ di contenere altre righe.

Per fare operazioni di modifica o selezione sui dati dentro il nesting, si utilizza `UNNEST(nomeCampoConNestedCampo)` con un `EXCEPT(nomeCampoConNestedCampo)`. Questo per una questione di ordine o per ottimizzazione.

```
dbo_vw_PRJ_Projects
dbo_vw_PRJ_EntryLogQlik
dbo_vw_CDG_Category

dbo_vw_SERV_Service
dbo_SERV_Service_ActualData (if feeType > 0) operatore umano = srv_UpdOweB
```

dettaglio = dimensione
aggregazione = metrica
### Esercizio
---
`PRJ_Project / vw_PRJ_EntryLogQlik / vw_CDG_Category  `
1. Estrarre il numero di progetti di tipologia Interno, Aperti, con ragione sociale `Sigemi SRL`  

```sql
SELECT count(ProjectID) as Progetti_Aperti_Interni_SigemiSRL FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_PRJ_Projects`

WHERE ProjectType = "Interno" AND Organization = "SIGEMI SRL" AND Closed = false
``` 

2. Estrarre la media di ore per progetti con Business Unit Time & Material, tenendo conto solo delle ore approvate dal manager  

```sql
SELECT Organization, ROUND(avg(Entry), 2) as AVG_Entries, ROUND(avg(InvoicedEntry), 2) as AVG_Invoiced_Entries FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_PRJ_EntryLogQlik`

WHERE Sign = true

GROUP BY Organization

-- Correction

SELECT

  cat.BU_Descr,

  ROUND(SUM(WorkedHours), 2) as Total_Worked_Hours,

  ROUND(avg(WorkedHours), 2) as AVG_WorkedHours

  

FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_PRJ_Projects` as prj

  

INNER JOIN `xtsDATA_sigemi.dbo_vw_PRJ_EntryLogQlik` as enLog

  ON prj.ProjectID = enLog.ProjectID

INNER JOIN `xtsDATA_sigemi.dbo_vw_CDG_Category` as cat

  ON prj.ID_Category = cat.ID_Category

  

WHERE

  Sign = true AND

  cat.BU_Descr Like "Time & Material"

GROUP BY

  cat.BU_Descr
```

3. Estrarre la lista di tutti i progetti in ritardo in ordine decrescente dal più in ritardo  

```sql
SELECT 
  dbo_vw_PRJ_Projects.Title,
  `sigemi-prod.xtsDATA_sigemi.dbo_vw_CDG_Category`.Description as Category,
  dbo_vw_PRJ_Projects.EstimatedEndDate,
  dbo_vw_PRJ_Projects.ClosedDate as ActualCloseDate,
  CASE

FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_CDG_Category`

RIGHT JOIN sigemi-prod.xtsDATA_sigemi.dbo_vw_PRJ_Projects
ON `sigemi-prod.xtsDATA_sigemi.dbo_vw_CDG_Category`.ID_Category = dbo_vw_PRJ_Projects.ID_Category

WHERE 
dbo_vw_PRJ_Projects.ClosedDate > dbo_vw_PRJ_Projects.EstimatedEndDate OR 
( CURRENTD_DATE() > dbo_vw_PRJ_Projects.EstimatedEndDate AND
 Closed = FALSE)

ORDER BY 
--dbo_vw_PRJ_Projects.ClosedDate - dbo_vw_PRJ_Projects.EstimatedEndDate DESC
5 DESC -- ordina per la quinta colonna

-- Correction

SELECT

  dbo_vw_PRJ_Projects.Title,

  dbo_vw_PRJ_Projects.EstimatedEndDate,

  CASE

    WHEN Closed THEN DATE_DIFF(dbo_vw_PRJ_Projects.ClosedDate, dbo_vw_PRJ_Projects.EstimatedEndDate, DAY)

    WHEN NOT Closed THEN DATE_DIFF(current_date(), dbo_vw_PRJ_Projects.EstimatedEndDate, DAY)

  END as Days_Late

  

FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_CDG_Category`

  

RIGHT JOIN sigemi-prod.xtsDATA_sigemi.dbo_vw_PRJ_Projects

ON `sigemi-prod.xtsDATA_sigemi.dbo_vw_CDG_Category`.ID_Category = dbo_vw_PRJ_Projects.ID_Category

  

WHERE

dbo_vw_PRJ_Projects.ClosedDate > dbo_vw_PRJ_Projects.EstimatedEndDate OR

( current_date() > dbo_vw_PRJ_Projects.EstimatedEndDate AND

 Closed = FALSE)

  

ORDER BY

3 DESC
```
  
`vw_SERV_Service (FeeType - 0: Fisso, 1: Consuntivo, 2: Conguaglio, 3: Flex) / SERV_Service_ActualData  `
1. Estrarre un consuntivo al mese per servizio tenendo conto della validità, della data di validità e dell'inserimento  

```sql
SELECT

Service,

EXTRACT(MONTH FROM serva.BilledOn) AS MONTH_BILLED,

EXTRACT(YEAR FROM serva.BilledOn) AS YEAR_BILLED

FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_SERV_Service` serv

LEFT JOIN sigemi-prod.xtsDATA_sigemi.dbo_SERV_Service_ActualData serva

ON serv.ID_Service = serva.ID_Service

WHERE

FeeType IN (1,2,3) AND

serva.BilledOn IS NOT NULL AND

serva.IsValid = true AND

serva.ValidDate IS NOT NULL AND

serva.InsertDate IS NOT NULL

GROUP BY

Service,

MONTH_BILLED,

YEAR_BILLED

ORDER BY

Service,

YEAR_BILLED

-- Correction

SELECT
	serv.ID_Service,
	servvwa.Cliente,
	CASE
	  WHEN FeeType = 1 THEN "Consuntivo"
	  WHEN FeeType = 2 THEN "Conguaglio"
	  WHEN FeeType = 3 THEN "Flex"
	END as FeeType,
	EXTRACT(MONTH FROM serva.BilledOn) AS MONTH_BILLED,
	EXTRACT(YEAR FROM serva.BilledOn) AS YEAR_BILLED

FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_SERV_Service` serv

LEFT JOIN sigemi-prod.xtsDATA_sigemi.dbo_SERV_Service_ActualData as serva
  ON serv.ID_Service = serva.ID_Service
LEFT JOIN sigemi-prod.xtsDATA_sigemi.dbo_vw_SERV_ServiceActualData as servvwa
  ON serv.ID_Service = servvwa.ID_Service
  
WHERE
	FeeType IN (1,2,3) AND
	serva.BilledOn IS NOT NULL AND
	serva.IsValid = true AND
	serva.ValidDate IS NOT NULL AND
	serva.InsertDate IS NOT NULL

GROUP BY
	servvwa.Cliente,
	FeeType,
	serv.ID_Service,
	MONTH_BILLED,
	YEAR_BILLED

ORDER BY

	serv.ID_Service,
	YEAR_BILLED
```

2. Estrarre tutti i servizi a conguaglio / flex che nell'ultimo mese hanno superato la quantità prevista  

```sql
SELECT

ID_Service,

EXTRACT(MONTH FROM serva.BilledOn) AS MONTH_BILLED,

EXTRACT(YEAR FROM serva.BilledOn) AS YEAR_BILLED,

FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_SERV_Service` serv

LEFT JOIN sigemi-prod.xtsDATA_sigemi.dbo_SERV_Service_ActualData serva

ON serv.ID_Service = serva.ID_Service

WHERE

FeeType In (2,3) AND

serva.BilledOn IS NOT NULL AND

serva.IsValid = true AND

serva.ValidDate IS NOT NULL AND

serva.InsertDate IS NOT NULL AND

serv.Qta < serva.Quantity

GROUP BY

Service,

MONTH_BILLED,

YEAR_BILLED

HAVING

MONTH_BILLED = EXTRACT(MONTH FROM DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH)) AND

YEAR_BILLED = EXTRACT(YEAR FROM DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH))

ORDER BY

Service,

YEAR_BILLED

-- Correction

SELECT

  ID_Service,

  Cliente,

  FeeType,

  MONTH_BILLED,

  YEAR_BILLED,

  OverBy,

From (

  SELECT

    serv.ID_Service,

    servvwa.Cliente,

    CASE

      WHEN FeeType = 2 THEN "Conguaglio"

      WHEN FeeType = 3 THEN "Flex"

    END as FeeType,

    EXTRACT(MONTH FROM serva.BilledOn) AS MONTH_BILLED,

    EXTRACT(YEAR FROM serva.BilledOn) AS YEAR_BILLED,

    SAFE_SUBTRACT(serva.Quantity, serv.Qta) as OverBy,

    RANK() OVER(

      PARTITION BY serv.ID_Service, EXTRACT(MONTH FROM serva.BilledOn), EXTRACT(YEAR FROM serva.BilledOn)

      ORDER BY ValidDate, InsertDate

    ) as servRank

  

  FROM `sigemi-prod.xtsDATA_sigemi.dbo_vw_SERV_Service` serv

  

  LEFT JOIN sigemi-prod.xtsDATA_sigemi.dbo_SERV_Service_ActualData serva

    ON serv.ID_Service = serva.ID_Service

  RIGHT JOIN sigemi-prod.xtsDATA_sigemi.dbo_vw_SERV_ServiceActualData as servvwa

    ON serv.ID_Service = servvwa.ID_Service

  

  WHERE

    FeeType In (2,3) AND

    serva.IsValid = true AND

    serva.ValidDate IS NOT NULL AND

    serva.InsertDate IS NOT NULL AND

    serv.Qta < serva.Quantity

  

  GROUP BY

    serv.ID_Service,

    servvwa.Cliente,

    FeeType,

    MONTH_BILLED,

    YEAR_BILLED,

    serva.BilledOn,

    serv.Qta,

    serva.Quantity,

    ValidDate,

    InsertDate

  

  HAVING

    MONTH_BILLED = EXTRACT(MONTH FROM DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH)) AND

    YEAR_BILLED = EXTRACT(YEAR FROM DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH))

  

  ORDER BY

    OverBy desc

)

  

WHERE

  servRank = 1
```

#### Charts
Su Looker Studio: realizzare una dashboard che mi permetta di analizzare i consuntivi dei servizi, evidenziando i servizi che sforano la quantità prevista (se la hanno), e tutti i servizi che attualmente non hanno un dato di consuntivo nel mese di dicembre. Quale servizio ha il consuntivo più alto per tipo di fatturazione? per cliente?

>[!NOTE]
>Documentazione grafici da utilizzare: [Documentazione Grafici](https://datavizcatalogue.com/index.html)

### Correzioni da implementare
---
Case -> if molto elaborata.

```sql
CASE
	WHEN 'condition 1' Then 'result 1'
	WHEN 'condition 2' Then 'result 2'
	ELSE 'result 3'
END
```

Il tipo del risultato deve essere uguale per tutti i then e else.

Date diff -> differenza per data e poi specificare quale campo sottrarre. Ex(DATE.DIFF(date1, date2, DAY))

Funzioni analitiche, funzioni fatte per l'analisi, non possono essere utilizzate da sole.

```bq
ES1P2
Rank() -> ordinamento per delle condizioni
First_Value() -> stessa cosa ma estrae il primo di una lista secondo condizioni
Last_Value() -> stessa cosa ma estrae l'ultimo di una lista secondo condizioni

-- tra le parentesi di rank(), first_value(), last_value()
-- rank() non prende niente
-- first() e last prende il valore da tirare fuori

Over -> si usa per tutte le condizioni analitiche
over (condizione)

Ex.
Where
	Rank() Over(Partition By Id_Servizio, Year/Month Valid_date
	Order By Valid_date, Insert_date Desc) = 1

First_Value() Over() -- stessa cosa per quella di prima ma senza utilizzare desc o asc.
```

Lead prende il valore successivo, Lag il valore precedente.