### File di configurazione
----
La repository principale e' `etl-deploy`, che contiene tutti i file di configurazione per la deploy dei vari ETL su `kubernetes`.

Config `openetl` (interfaccia): configurazione da mandare per a `selfAdmin`.

Api: (in `rest-to-bq`) serve per dire dove prendere i dati (prod o dev).

Project: progetti sono quelli in google.

Data set: sono i data set dove mettere i dati su `bq`.

id-ditta: codice relativo alla api.

service-account-key: file di configurazione con i permessi dell'account.

flusso: nome che si da' al flusso. (se non c'e' questo nome nel codice di `rest-to-bq` con il parsing dei campi, perche' i `rest-to-bq` hanno una sola immagine che prende i dati e li salva, le uniche cose che cambiano sono i dati di riferimento, magari delle query e i data set di riferimento dove salvare questi dati)

Secret: password. (ovviamente non in chiaro, ma il path del file con la password salvata su google secret manager) Ma se non c'e' il service account non funzionerebbe e se non ha il permessi allora ti avvisa che l'account non ha i permessi. 

data-mode: fa riferimento a quello che deve fare il flusso (merge-with-keep, delete-merge-keep, delete-and-insert, etc...)

first-delete-custom-where-condition: query di aggiunta prima della delete.

`quarkus`:
	log:
		console:
			`json`: true
- formato di salvataggio del log (quello che accetta google sono i `json`)

>[!WARNING]
>PERMESSI CAZO

### Aggiornamento immagine
---
Bisogna aggiornare il file di configurazione di `kubernetes`, con dentro:
- api version
- resources: cronjob
- path: dove si trova in artifact registry di google 
- etc...

Poi basta fare la push.
### CRM
---
Per i CRM (.csv) si utilizza il protocollo `sftp`, uno storage condiviso dove i dati, da convertire ed inseriti su `bq`, vengono inseriti come file ed estratti.

Per capire quando vengono aggiunti file, ci sono 2 metodi:
- async -> dove viene fatto il set up di trigger del sistema operativo che notifica l'utente quando lo storage e' stato aggiornato, ma nel nostro caso non si puo' usare visto che utilizziamo uno storage `sftp`.
- sync -> con il polling che ad una frequenza determinata tra di noi continua ad essere eseguito.
	- Polling -> chiede continuamente aggiornamenti per la `sftp`.